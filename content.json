{"posts":[{"title":"InvidiousインスタンスをPodman上に建てる","text":"概要Invidious というYoutubeのフロントエンドをRHEL 9.3で動かしてみたメモです。RHELにはDockerの代わりにPodmanが採用されているのでPodman上でコンテナを走らせてみます。 環境以下のコマンド実行結果を参照 12345678910$ cat /etc/redhat-releaseRed Hat Enterprise Linux release 9.3 (Plow)$ podman -vpodman version 4.6.1$ whoamiinvidious$ pwd/home/invidious$ lsinvidious invidious_podman.yml postgres InvidiousのリポジトリをクローンはじめにInvidiousのリポジトリを適当なディレクトリにクローンします。この記事では/home/invidious/ディレクトリにクローンします。 1$ git clone https://github.com/iv-org/invidious.git postgresqlのデータ保存先の作成この記事では/home/invidious/postgresとします。まずはフォルダを作ります 123$ pwd /home/invidious/$ mkdir postgres 権限とSELinuxコンテキストをつけてコンテナから参照できるようにします。 123$ sudo semanage fcontext -a -t container_file_t &quot;/home/invidious/postgres(/.*)?&quot;$ chmod 777 &quot;/home/invidious/postgres&quot;$ sudo restorecon -FR /home/invidious/ KubernetesのPod構成ファイルを作成このymlファイルを保存して編集する。編集箇所は以下の通り 11行目 - postgresqlのデータ保存先ディレクトリを指定 15行目、19行目 - /home/invidious/invidious を自分がリポジトリをクローンしたパスに書き換え 40行目 - HMACキーを乱数に変更 40行目の乱数については以下のコマンドで質の良い乱数を得られます※この記事からコピペせず自分の環境で実行した物をコピペしてください 12$ head /dev/urandom | sha256sum9785539ca38e85d41af29064802e93c541549f8e1a93fd6adedb45fed244602d - 実行1234567891011121314151617181920212223242526272829303132333435363738394041$ sudo podman kube play invidious_podman.ymlTrying to pull quay.io/invidious/invidious:latest...Getting image source signaturesCopying blob 82fa84ecc937 doneCopying blob 5663860407a6 doneCopying blob 4deca27c4269 doneCopying blob 88aba340a58e doneCopying blob 619be1103602 skipped: already existsCopying blob f5799a41fb4b doneCopying blob 028fa9dd7876 doneCopying blob f16baffbff6d doneCopying blob 64b04972d66a doneCopying blob 398066e4a327 doneCopying blob fe91b20bd915 doneCopying blob 4f4fb700ef54 skipped: already existsCopying config f59a293603 doneWriting manifest to image destinationTrying to pull docker.io/library/postgres:14...Getting image source signaturesCopying blob c8b33fe17167 skipped: already existsCopying blob aaed90dbec0c skipped: already existsCopying blob e1caac4eb9d2 skipped: already existsCopying blob 9a16433c9ffb skipped: already existsCopying blob ab2fbdc548a0 skipped: already existsCopying blob d5dfacd95d04 skipped: already existsCopying blob 5c2653ccff30 skipped: already existsCopying blob 8e5372f9ff7e skipped: already existsCopying blob 927d619c5510 skipped: already existsCopying blob 116545f99854 skipped: already existsCopying blob 9762cab69057 skipped: already existsCopying blob 79f98701f9d8 skipped: already existsCopying blob e837237b2223 skipped: already existsCopying blob ebb0ebcc01bc skipped: already existsCopying config 28948ca129 doneWriting manifest to image destinationPod:21082c4f513294020c6ed2cb47458292ce55b208b649eeb3b1b5f54052037370Containers:27b3f08f0ceac85cfb69c907269c2e68a5e0c2b5e63f38565113bb119abd09bda862da1477a23fb08fcb6b5fe23c55fb3c16f0e6fb4a0b6ee1119e4152e62942 動作確認最初は立ち上がってくるまでに数分がかかる数分後にcurlコマンドでコンテナが動いているか確認 123456789101112$ curl -I localhost:3000HTTP/1.1 200 OKConnection: keep-aliveContent-Type: text/htmlX-Frame-Options: sameoriginX-XSS-Protection: 1; mode=blockX-Content-Type-Options: nosniffContent-Security-Policy: default-src 'none'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'; manifest-src 'self'; media-src 'self' blob: https://*.googlevideo.com:443 https://*.youtube.com:443; child-src 'self' blob:; frame-src 'self'; frame-ancestors 'none'Referrer-Policy: same-originPermissions-Policy: interest-cohort=()Content-Length: 0 公開ファイアウォール設定を変更し、3000番が通るようにする。 12$ sudo firewall-cmd --permanent --add-port=3000/tcp$ sudo firewall--cmd --reload 3000番以外のポートを使用した場合は、ymlファイルの28行目を編集する。 うちの環境ではnginxをSSLアクセラレータにして、以下のような設定で動かしている 123456789101112131415161718192021222324server{ listen 443 ssl http2; listen [::]:443 ssl http2; server_name &lt;ドメイン名&gt;; # ssl on; ssl_certificate &lt;証明書&gt;; ssl_certificate_key &lt;秘密鍵&gt;; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; location / { proxy_pass http://&lt;Invidiousを立てたサーバ&gt;:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $remote_port; port_in_redirect off; add_header Front-End-Https on; add_header 'Strict-Transport-Security' 'max-age=15552000;';}","link":"/2024/03/10/Invidious%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%82%92Podman%E4%B8%8A%E3%81%AB%E5%BB%BA%E3%81%A6%E3%82%8B/"},{"title":"Knot-ResolverでAndroid向けの広告をブロック","text":"概要Knot-Resolverを使い、Androidの「プライベートDNS設定」で利用できるDoTサーバーを構築しますまた、RPZゾーンの機能を利用し広告ブロックも行います DoTを利用するには何でもいいのでドメインが必要になります。ドメインを持っていない人はMyDNSなど、無料の物を利用してもかまいません。 環境12$ cat /etc/redhat-releaseRed Hat Enterprise Linux release 9.3 (Plow) EPELを有効にする今回はRHELを使用しているので、Subscription ManagerからEPELを有効にしていきます 12$ sudo subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms$ sudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm knot-resolverをインストールするknot-resolverはdnfからすんなりインストールできます 1$ sudo dnf install knot-resolver RPZゾーンファイルを用意するdns-blというRPZを自動生成するスクリプトを利用します。かなり古いですが、正常動作を確認しています。 dns-blのインストール12$ cd /opt/$ sudo https://github.com/p7cq/dns-bl.git configファイルの編集1$ sudo vim /opt/dns-bl/conf/dns-bl.ini 複数の広告除去用hostsファイルやマルウェア配布URLリストを指定したコンフィグを例示します。コピペで上書きしてください 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[global]rpz_file = /etc/knot-resolver/rpz.zoneredirect = IN CNAME .# whitelisted domainswhitelist_file_prefix = whitelist_[source/1]url = https://urlhaus.abuse.ch/downloads/hostfile/file_type = textcategories = malwareenabled = yes[source/2]url = https://raw.githubusercontent.com/blocklistproject/Lists/master/alt-version/ads-nl.txtfile_type = textcategories = adsenabled = yes[source/3]url = https://logroid.github.io/adaway-hosts/hosts.txtfile_type = textcategories = adsenabled = yes[source/4]url = https://adaway.org/hosts.txtfile_type = textcategories = adsenabled = yes[source/5]url = https://warui.intaa.net/adhosts/hosts_lb.txtfile_type = textcategories = adsenabled = yes[source/6]url = https://raw.githubusercontent.com/StevenBlack/hosts/master/hostsfile_type = textcategories = adsenabled = yes[source/7]url = https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&amp;showintro=0&amp;mimetype=plaintextfile_type = textcategories = adsenabled = yes 自動更新スクリプトの作成dns-blを定期的に実行してrpzファイルを更新するスクリプトを作成します。本記事ではこのスクリプトを/root/scripts/rpz_update.shという名前で保存しています。 12$ sudo su# vim /root/scripts/rpz_update.sh 以下のシェルスクリプトをコピペで上書きしてください。 12345#!/bin/bash/opt/dns-bl/bin/run.shchown knot-resolver:knot-resolver /etc/knot-resolver/rpz.zonerestorecon -FR /etc/knot-resolver/systemctl restart kresd@* その後、実行権限を付与してください 1# chmod +x /root/scripts/rpz_update.sh Cron設定cronに上記スクリプトを登録します 1# sudo crontab -e テキストエディタが開いたら以下のように入力してください(毎日00:00に更新) 10 0 * * * /bin/bash /root/scripts/rpz_update.sh ZeroSSLで証明書を取得するZeroSSLからTLSサーバ証明書を取得します。※LetsEncryptを使用するとAndroidの一部のバージョンでは正常に利用できません 以下の記事を参考に証明書ファイルをダウンロードしてください。ブラウザから無料で簡単に証明書を発行できる ZeroSSL | DevelopersIO その後、取得した証明書はサーバの/etc/knot-resolver/に保存します。 この記事では秘密鍵をprivkey.pem証明書をfullchain.pemという名前で保存しています。別の名前で保存した場合は設定ファイルの1行目を書き換えてください。 knot-resolverの設定Configを編集します 1$ sudo vim /etc/knot-resolver/kresd.conf 以下のconfigをコピペで上書きしてください 123456789101112131415net.tls(&quot;/etc/knot-resolver/fullchain.pem&quot;,&quot;/etc/knot-resolver/privkey.pem&quot;)net.listen('0.0.0.0', 53, { kind = 'dns' })net.listen('0.0.0.0', 853, { kind = 'tls' })modules = { 'hints &gt; iterate', 'stats', 'predict', 'view',}view:addr('192.168.0.0/16',policy.all(policy.PASS))view:addr('172.16.0.0/12',policy.all(policy.PASS))view:addr('10.0.0.0/8',policy.all(policy.PASS))view:addr('0.0.0.0/0',policy.all(policy.TC))policy.add(policy.rpz(policy.DENY, '/etc/knot-resolver/rpz.zone'))log_level('warning') kresdを起動はじめに自動更新スクリプトを手動で実行し、RPZファイルを事前生成しておきます実行に成功すると生成されたゾーンファイルの行数か何かが出力されます。 123$ sudo su# /root/scripts/rpz_update.sh346934 kresdを起動します 12$ sudo systemctl enable kresd@1$ sudo systemctl start kresd@1 動作確認123456789101112131415C:\\Users\\admin&gt;nslookup google.com &lt;サーバIP&gt;サーバー: UnKnownAddress: &lt;サーバIP&gt;権限のない回答:名前: google.comAddresses: 2404:6800:4004:823::200e 142.250.199.110C:\\Users\\admin&gt;nslookup ads.google.com &lt;サーバIP&gt;サーバー: UnKnownAddress: &lt;サーバIP&gt;*** UnKnown が ads.google.com を見つけられません: Non-existent domain 参考資料How to install EPEL on RHEL and CentOS Stream | Enable Sysadminブラウザから無料で簡単に証明書を発行できる ZeroSSL | DevelopersIOConfiguration Overview — Knot Resolver 5.7.1 documentation","link":"/2024/03/10/Knot-Resolver%E3%81%A7Android%E5%90%91%E3%81%91%E3%81%AE%E5%BA%83%E5%91%8A%E3%82%92%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF/"},{"title":"LGPO.exeでGPO(グループポリシー)をバックアップ・管理する","text":"概要LGPO.exeを使ってローカルグループポリシーをバックアップおよび復元する方法と，自作の簡易的なバックアップ管理ツールを紹介します． パソコンの移行時やキッティングに活用ください．また，WindowsのProエディションで適用しているGPOをHomeエディションに移植できるという小ネタにもなります． LGPO.exeのダウンロードダウンロードページを開き，Downlaodをクリック ① LGPO.zip にチェックを入れ② Download をクリック ダウンロードしたLGPO.exeを任意の場所に展開する GPOの保存次のコマンドでGPOを保存できます．※保存先のパスはフルパスで指定する必要がありました 1LGPO.exe /b [保存先ディレクトリのフルパス] 保存先のパスに新しくフォルダが作成され，その中にGPOのバックアップが作成されます．フォルダ名はUUIDv4で指定され，{56880275-2D86-4531-BEE8-AA3B5AF4529A}のような名前になります GPOの復元次のコマンドで保存されたGPOを復元できます．※保存先のパスはバックアップ時と同じものではなく，バックアップ時に新規作成されるフォルダ名がUUIDv4の物をフルパスで指定する必要がありました． 1LGPO.exe /g [保存先ディレクトリのフルパス] 簡易的な管理ツール著者が作成した簡易的なバックアップ管理ツールの使い方も紹介します． はじめに以下のリンク先からPowershellスクリプトを保存します．backupmgr.ps1 ①Rawを右クリック②名前をつけてリンク先を保存をクリック保存先を指定するダイアログでLGPO.exeを保存したディレクトリに保存 backupmgr.ps1を右クリックし，Powershellで実行をクリックするとスクリプトが起動します 保存メニューで1を入力すると，ファイル名の入力を促されます．※デフォルト値はホスト名と日付になっています． ファイル名を入力もしくはそのままEnterを押すと，UACダイアログが立ち上がりバックアップが作成されます．すでに同名のバックアップが存在する場合はエラーが表示されます． 復元メニューで2を入力するとバックアップ一覧が表示され，復元対象の選択を促されます． 選択対象を入力すると，UACダイアログが立ち上がり復元が行われます． 参考文献LGPO.exe - Local Group Policy Object Utility, v1.0 | Microsoft Community Hub","link":"/2025/03/13/LGPO-exe%E3%81%A7GPO-%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97%E3%83%9D%E3%83%AA%E3%82%B7%E3%83%BC-%E3%82%92%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%83%BB%E7%AE%A1%E7%90%86%E3%81%99%E3%82%8B/"},{"title":"LibreOffice Drawを使ってPDF文書をPDF&#x2F;A形式に変換する","text":"概要PDFをPDF/A規格に準拠した形に変換します. LibreOffice DrawLibreOffice Drawは無料で利用できる作図ソフトです．あまり知られていませんが，強力なPDF編集ツールになります．今回はそんなLibreOffice Drawを使って通常のPDF文書をPDF/Aに準拠した形に変換します． PDF文書をPDF/A形式に変換 LibreOffice DrawでPDFファイルを開く 「ファイル」-&gt;「次の形式でエクスポート」-&gt;「PDFとしてエクスポート」の順にクリック PDFオプションの「全般」の項目で「アーカイブ」にチェックを付ける PDF/Aバージョンを選択するPDF/AバージョンについてはWikipediaを参照してください 「エクスポート」ボタンをクリックして保存先を指定する 上記の手順でPDF/A形式への変換が行えます．領収書等の提出などをPDF/A形式で求められた際にご活用下さい","link":"/2025/03/05/LibreOffice-Draw%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6PDF%E6%96%87%E6%9B%B8%E3%82%92PDF-A%E5%BD%A2%E5%BC%8F%E3%81%AB%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B/"},{"title":"NFStreamのセットアップ(WSL+OracleLinux9+Python3.12)","text":"概要通信解析用のフレームワーク「NFStream」をPython 3.12とWSL2環境に対してインストールします。 環境WSL2にインストールしたOracle Linux 9.1を使用します。 12345678910111213141516171819$ cat /etc/os-releaseNAME=&quot;Oracle Linux Server&quot;VERSION=&quot;9.1&quot;ID=&quot;ol&quot;ID_LIKE=&quot;fedora&quot;VARIANT=&quot;Server&quot;VARIANT_ID=&quot;server&quot;VERSION_ID=&quot;9.1&quot;PLATFORM_ID=&quot;platform:el9&quot;PRETTY_NAME=&quot;Oracle Linux Server 9.1&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:oracle:linux:9:1:server&quot;HOME_URL=&quot;https://linux.oracle.com/&quot;BUG_REPORT_URL=&quot;https://github.com/oracle/oracle-linux&quot;ORACLE_BUGZILLA_PRODUCT=&quot;Oracle Linux 9&quot;ORACLE_BUGZILLA_PRODUCT_VERSION=9.1ORACLE_SUPPORT_PRODUCT=&quot;Oracle Linux&quot;ORACLE_SUPPORT_PRODUCT_VERSION=9.1 セットアップ前提パッケージの導入WSLに導入したばかりのOracleLinuxには基本的なコマンドや開発ツールが無いため、以下のコマンドで必要なパッケージをインストールします。 123sudo dnf group install &quot;Minimal Install&quot;sudo dnf group install &quot;Development Tools&quot;sudo dnf install libpcap libpcap-devel --enablerepo=ol9_codeready_builder Pythonのインストール以下のコマンドでPython3.12を導入し、デフォルトのPythonパッケージに指定します。 12sudo dnf install python3.12 python3.12-devel python3.12-libs python3.12-libs python3.12-pipsudo alternatives --install /usr/bin/python python /usr/bin/python3.12 1 nfstreamのインストールNFStreamのリポジトリをクローンします。 12git clone --recurse-submodules https://github.com/nfstream/nfstream.gitcd nfstream ※記事執筆時点のバージョンで固定する場合 1git checkout a4180aa52fbc9f135b8ecfe039652845047b176b スクリプトの誤りを修正します 1sed 's|/tmp/nfstream_build/{usr}/lib/libndpi.a|/tmp/nfstream_build/{usr}/lib64/libndpi.a|g' -i ./nfstream/engine/engine_build.py 上記コマンド実行後、差分が次のようになっていれば成功です。 12345678910111213diff --git a/nfstream/engine/engine_build.py b/nfstream/engine/engine_build.pyindex c3bf6a9..8548f6a 100644--- a/nfstream/engine/engine_build.py+++ b/nfstream/engine/engine_build.py@@ -83,7 +83,7 @@ INCLUDE_DIRS = [ &quot;{root}/tmp/nfstream_build/{usr}/include&quot;.format(root=ROOT, usr=USR_LOCAL), ] EXTRALINK_ARGS = [- &quot;{root}/tmp/nfstream_build/{usr}/lib/libndpi.a&quot;.format(root=ROOT, usr=USR)+ &quot;{root}/tmp/nfstream_build/{usr}/lib64/libndpi.a&quot;.format(root=ROOT, usr=USR) ] if os.name != &quot;posix&quot;: # Windows インストールします 123python -m pip install --upgrade pippython -m pip install -r dev_requirements.txtpython -m pip install . テストサンプルとなるcapファイルをダウンロードします。 12cd ~wget https://wiki.wireshark.org/uploads/27707187aeb30df68e70c8fb9d614981/http.cap 以下のpythonスクリプトをnfstream_test.pyのファイル名で保存 1234from nfstream import NFStreamers = NFStreamer(source=&quot;http.cap&quot;)for flow in s : print(flow) 保存したnfstream_test.pyを実行 1234567891011python nfstream_test.pyNFlow(id=0, expiration_id=0, src_ip=145.254.160.237, src_mac=00:00:01:00:00:00, src_oui=00:00:01, src_port=3372, dst_ip=65.208.228.223, dst_mac=fe:ff:20:00:01:00,(中略)","link":"/2025/03/07/NFStream%E3%81%AE%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97-WSL-OracleLinux9-Python3-12/"},{"title":"OpensslでEC(楕円曲線)のクライアント証明書を作成する","text":"概要Opensslでクライアント証明書を作成する方法はよく紹介されているがほとんどがRSA暗号を用いた物だったため、EC(楕円曲線)暗号を用いたクライアント証明書の作成方法を調べました。 おまけとしてnginxで利用する際の設定も紹介します CA証明書の生成CAとは証明書を発行する機関の事です。PKIはクライアントがCAを信頼しそのCAが発行した証明書を許可するという仕組みのため、オレオレ証明書でもCAの作成が必要です。 設定ファイルの記述CA.txtというファイル名でファイルを作成し、以下の内容をコピペします。これは参考文献(1)からそのまま持ってきました。 1234subjectKeyIdentifier=hashauthorityKeyIdentifier=keyid:always,issuer:alwaysbasicConstraints=CA:TRUEkeyUsage=keyCertSign,cRLSign 証明書の生成以下のコマンドを実行します。 123$ sudo openssl ecparam -name secp384r1 -genkey -noout -out CA.key$ sudo openssl req -new -key CA.key -out CA.csr -subj &quot;/CN=Selfsign Root CA&quot;$ sudo openssl x509 -req -days 3650 -in CA.csr -signkey CA.key -extfile CA.txt -out CA.crt これで以下の通りファイルが生成されます ファイル名 用途 CA.key CAの秘密鍵 CA.csr CAの証明書発行要求 CA.crt CAの証明書 クライアント証明書の発行続いて、実際に使用するクライアント証明書を作成します。 設定ファイルの記述Client.txtというファイル名でファイルを作成し、以下の内容をコピペします。これは参考文献(1)からそのまま持ってきました。 12345basicConstraints=CA:FALSEsubjectKeyIdentifier=hashauthorityKeyIdentifier=keyid,issuer:alwaysextendedKeyUsage=clientAuthkeyUsage=digitalSignature クライアント証明書の生成以下のコマンドを実行します。 123$ sudo openssl ecparam -name secp384r1 -genkey -noout -out Client.key$ sudo openssl req -new -key Client.key -out Client.csr -subj &quot;/CN=Client&quot;$ sudo openssl x509 -req -in Client.csr -CA CA.crt -CAkey CA.key -CAcreateserial -days 3650 -extfile Client.txt -out Client.crt これで以下の通りファイルが生成されます ファイル名 用途 Client.key クライアントの秘密鍵 Client.csr クライアントの証明書発行要求 Client.crt クライアントの証明書 Nginxへの設定方法(おまけ)ssl_certificateとかの設定が書いてある所に書いてください。 12ssl_client_certificate &quot;&lt;CA.crtのファイルパス&gt;&quot;;ssl_verify_client on; WindowsやAndroidに証明書をインポートする方法PKCS12形式に変換します。※ここで-legacyオプションをつけないとAndroidにインポートできない 1$ sudo openssl pkcs12 -export -legacy -in Client.crt -inkey Client.key -certfile CA.crt -out Client.pfx これでWindows/Androidで扱える形式になりました。Client.pfxをコピーして、利用してください。 Windowsの場合は、ダブルクリックするとウィザードが立ち上がるので指示に従ってインストールしてください。主要なブラウザからはこれだけで使えるようになります。 Androidの場合は以下の通り設定画面を開く設定 -&gt; セキュリティ -&gt; セキュリティの詳細設定 -&gt; 暗号化と認証情報 -&gt; 証明書のインストール -&gt; VPNとアプリユーザー証明書 ファイルピッカーが表示されたらClient.pfxをタップして開く パスワードの入力を求められたら、変換時に入力したパスワードを入力する。 Androidでオレオレクライアント証明書を扱えるブラウザは(自分が試した限りでは)Operaだけでした。 参考文献(1) 自己署名CAをOpenSSLコマンドラインオプションで使う #OpenSSL - Qiita","link":"/2024/03/22/Openssl%E3%81%A7EC-%E6%A5%95%E5%86%86%E6%9B%B2%E7%B7%9A-%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E8%A8%BC%E6%98%8E%E6%9B%B8%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B/"},{"title":"Windows11環境でパスキー(Yubikey)利用時に出る「iPhone、iPad、またはAndroidデバイス」の選択肢を消す方法","text":"概要「iPhone、iPad、またはAndroidデバイス」の選択肢が毎回1番目に表示されて邪魔すぎるので無効にします 方法田+Rで「ファイル名を指定して実行」を呼び出し、devmgmt.mscと入力して「OK」をクリック Bluetoothを無効にする。 Bluetoothデバイスとの共存は無理そうなので、会議通話などで使用する方は、USBオーディオに変換するタイプのアダプタを購入する必要があります。Amazon | Creative BT-W3X PS4/PS5/Nintendo Switch使用可能 aptX HD 最大24bit/48kHz USB-C接続 Bluetooth 5.3 オーディオ トランスミッター HP-BTW3X | クリエイティブ・メディア | Bluetoothアダプタ 通販※アフィリンクなし 参考文献Disable “iPhone, iPad, or Android device” option for Passkey Sign-in - Microsoft Community","link":"/2024/09/26/Windows11%E7%92%B0%E5%A2%83%E3%81%A7%E3%83%91%E3%82%B9%E3%82%AD%E3%83%BC-Yubikey-%E5%88%A9%E7%94%A8%E6%99%82%E3%81%AB%E5%87%BA%E3%82%8B%E3%80%8CiPhone%E3%80%81iPad%E3%80%81%E3%81%BE%E3%81%9F%E3%81%AFAndroid%E3%83%87%E3%83%90%E3%82%A4%E3%82%B9%E3%80%8D%E3%81%AE%E9%81%B8%E6%8A%9E%E8%82%A2%E3%82%92%E6%B6%88%E3%81%99%E6%96%B9%E6%B3%95/"},{"title":"PoS移行後のEthereumプライベートチェーンを構築し送金してみる","text":"概要EthereumがPoSに移行した後，gethを使ってプライベートチェーンの構築を試みましたが，geth minerやgeth personalコマンドが存在せず，古い情報に従っても送金すらできませんでした． 加えて，PoS移行後の情報が極めて少なく，様々な公式ドキュメントやヘルプを読みあさりなんとか送金するところまでたどり着いたので，自分流のやり方として公開します． 前提条件 Ubuntu (docker使うからあんま変わらないかも) WSLでsystemdを有効化済み 公式ドキュメントに従いdocker-ceインストール済 やりたいこと アカウントAliceを作成 Aliceが100ETHを持った状態の初期ブロックを作成 Bobに送金 clef初期化clefは従来のgeth personalに変わる秘密鍵の管理サーバのようなものです．今回はアカウントごとにdockerコンテナを立ち上げてclefを動作させます．そのため，複数のアカウントを扱う場合，コマンド中のaliceという名前を読み替えてください． 以下のコマンドでclefの対話画面を立ち上げる 1234$ sudo docker run --rm -it --name alice_clef \\-v alice_clef_vl:/root/.clef \\ethereum/client-go:alltools-stable \\clef init --configdir /root/.clef 以下のようなメッセージが表示されたらokと入力しEnterキーを入力 1234567891011121314WARNING!Clef is an account management tool. It may, like any software, contain bugs.Please take care to- backup your keystore files,- verify that the keystore(s) can be opened with your password.Clef is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULARPURPOSE. See the GNU General Public License for more details.Enter 'ok' to proceed:&gt; パスワードを設定パスワードは10桁以上で2回繰り返して入力 1234The master seed of clef will be locked with a password.Please specify a password. Do not forget this password!Password: ***Repeat password: *** アドレス生成以下のコマンドで秘密鍵とETHアドレスを生成途中で初期化時と同じ確認やパスワードが求められるので適宜入力します 1234sudo docker run --rm -it --name alice_clef \\-v alice_clef_vl:/root/.clef \\ethereum/client-go:alltools-stable \\clef newaccount --keystore /root/.clef/keystore 以下のような表示が出ればアドレスの生成は完了． 1234INFO [09-25|06:21:31.481] Your new key was generated address=0x930620D7C29043423BaE931A4A88345a2ff725a6WARN [09-25|06:21:31.481] Please backup your key file! path=/root/.clef/keystore/UTC--2025-09-25T06-21-29.776639348Z--930620d7c29043423bae931a4a88345a2ff725a6WARN [09-25|06:21:31.481] Please remember your password!Generated account 0x930620D7C29043423BaE931A4A88345a2ff725a6 念のため以下のコマンドで鍵が保存されているか確認 1234sudo docker run --rm -it --name alice_clef \\-v alice_clef_vl:/root/.clef \\ethereum/client-go:alltools-stable \\clef list-accounts --keystore /root/.clef/keystore このように表示されればOK． 10x930620D7C29043423BaE931A4A88345a2ff725a6 (keystore:///root/.clef/keystore/UTC--2025-09-25T06-21-29.776639348Z--930620d7c29043423bae931a4a88345a2ff725a6) アドレスは後ほど使うため覚えておきます． clefサーバーを起動以下のコマンドでclefサーバを起動します．今回はポート番号50000としていますが，複数アカウントを使用する場合は重複しないように変更してください． 12345sudo docker run --rm -it --name alice_clef \\-v alice_clef_vl:/root/.clef \\-p 50000:50000 \\ethereum/client-go:alltools-stable \\clef --keystore /root/.clef/keystore --configdir /root/.clef --chainid 585858 --http --http.addr 0.0.0.0 --http.vhosts &quot;*&quot; --http.port 50000 その後，パスワードの入力などを行い，以下のようにアカウント情報が表示されたら起動成功． 12------- Available accounts -------0. 0x930620D7C29043423BaE931A4A88345a2ff725a6 at keystore:///root/.clef/keystore/UTC--2025-09-25T06-21-29.776639348Z--930620d7c29043423bae931a4a88345a2ff725a6 以降，このコンソールは立ち上げたままにして，新しいコンソールから作業を行います． KurotosisのインストールKurotosisはEthereumのプライベートチェーン構築を補助するツールです．network-params.ymlを定義することで必要なコンテナを一気に立ち上げてconfigを投入してくれます． まずはじめに，公式のインストールガイドを参照し，Kurotosisをインストールしてください．https://docs.kurtosis.com/install 設定ファイルの作成以下の設定ファイルの必要箇所を編集し，network-params.ymlというファイル名で保存． 12345678910111213141516171819participants: #Alice - el_type: geth el_image: &quot;ethereum/client-go:alltools-stable&quot; el_extra_params: ['--signer=http://&lt;ホストのIPアドレス&gt;:50000/'] cl_type: lighthouse #Bob - el_type: geth el_image: &quot;ethereum/client-go:alltools-stable&quot; cl_type: lighthouse - el_type: geth cl_type: tekunetwork_params: network_id: &quot;585858&quot; prefunded_accounts: '{&quot;&lt;Aliceのアドレス&gt;&quot;:{&quot;balance&quot;:&quot;100ETH&quot;}}'additional_services: - dora Kurotosisの起動以下のコマンドでKurotosisを起動 1$ sudo kurtosis run github.com/ethpandaops/ethereum-package --args-file ./network-params.yml 以下のような画面が表示されたら，Enterキーを入力 12345The Kurtosis CLI collects user metrics by default. These metrics are anonymized, private &amp; obfuscated. These metrics help us better understand what features are used, what features to invest in and what features might be buggy.In case you wish to not send metrics, you can do so by running - kurtosis analytics disableRead more at https://docs.kurtosis.com/advanced-concepts/metrics-philosophy✔ (Optional) Share your email address for occasional updates &amp; outreach for product feedback from Kurtosis: █ 最後に以下のような画面が表示されたら起動完了．このときの情報は後々必要になるので控えておく． 1234567891011121314151617181920212223242526272829303132333435363738========================================== User Services ==========================================UUID Name Ports Status2fa0759d0f19 cl-1-lighthouse-geth http: 4000/tcp -&gt; http://127.0.0.1:32784 RUNNING metrics: 5054/tcp -&gt; http://127.0.0.1:32785 quic-discovery: 9001/udp -&gt; 127.0.0.1:32772 tcp-discovery: 9000/tcp -&gt; 127.0.0.1:32786 udp-discovery: 9000/udp -&gt; 127.0.0.1:3277157b30e388a1e cl-2-lighthouse-geth http: 4000/tcp -&gt; http://127.0.0.1:32787 RUNNING metrics: 5054/tcp -&gt; http://127.0.0.1:32788 quic-discovery: 9001/udp -&gt; 127.0.0.1:32774 tcp-discovery: 9000/tcp -&gt; 127.0.0.1:32789 udp-discovery: 9000/udp -&gt; 127.0.0.1:327735a0d0ee91d86 cl-3-teku-geth http: 4000/tcp -&gt; http://127.0.0.1:32790 RUNNING metrics: 8008/tcp -&gt; http://127.0.0.1:32791 tcp-discovery: 9000/tcp -&gt; 127.0.0.1:32792 udp-discovery: 9000/udp -&gt; 127.0.0.1:3277536676219c6c8 dora http: 8080/tcp -&gt; http://127.0.0.1:32795 RUNNING2f9bb3e40158 el-1-geth-lighthouse engine-rpc: 8551/tcp -&gt; 127.0.0.1:32771 RUNNING metrics: 9001/tcp -&gt; http://127.0.0.1:32772 rpc: 8545/tcp -&gt; 127.0.0.1:32769 tcp-discovery: 30303/tcp -&gt; 127.0.0.1:32773 udp-discovery: 30303/udp -&gt; 127.0.0.1:32768 ws: 8546/tcp -&gt; 127.0.0.1:32770eeb653321f3a el-2-geth-lighthouse engine-rpc: 8551/tcp -&gt; 127.0.0.1:32776 RUNNING metrics: 9001/tcp -&gt; http://127.0.0.1:32777 rpc: 8545/tcp -&gt; 127.0.0.1:32774 tcp-discovery: 30303/tcp -&gt; 127.0.0.1:32778 udp-discovery: 30303/udp -&gt; 127.0.0.1:32769 ws: 8546/tcp -&gt; 127.0.0.1:32775c31ebc8e8aaa el-3-geth-teku engine-rpc: 8551/tcp -&gt; 127.0.0.1:32781 RUNNING metrics: 9001/tcp -&gt; http://127.0.0.1:32782 rpc: 8545/tcp -&gt; 127.0.0.1:32779 tcp-discovery: 30303/tcp -&gt; 127.0.0.1:32783 udp-discovery: 30303/udp -&gt; 127.0.0.1:32770 ws: 8546/tcp -&gt; 127.0.0.1:327804cb590a2e6ca validator-key-generation-cl-validator-keystore &lt;none&gt; RUNNINGe9e76f1af61a vc-1-geth-lighthouse metrics: 8080/tcp -&gt; http://127.0.0.1:32794 RUNNING1b7552662140 vc-2-geth-lighthouse metrics: 8080/tcp -&gt; http://127.0.0.1:32793 RUNNING gethとClefの接続確認はじめに，AliceとなるコンテナのIDを取得． 1$ sudo docker ps | grep el-1-geth 以下のような出力の54ba7f879b61という部分がAliceのコンテナIDです． 154ba7f879b61 ethereum/client-go:alltools-stable &quot;sh -c 'geth init --…&quot; 4 minutes ago Up 4 minutes 0.0.0.0:32769-&gt;8545/tcp, [::]:32769-&gt;8545/tcp, 0.0.0.0:32770-&gt;8546/tcp, [::]:32770-&gt;8546/tcp, 0.0.0.0:32771-&gt;8551/tcp, [::]:32771-&gt;8551/tcp, 0.0.0.0:32772-&gt;9001/tcp, [::]:32772-&gt;9001/tcp, 0.0.0.0:32768-&gt;30303/udp, 0.0.0.0:32773-&gt;30303/tcp, [::]:32768-&gt;30303/udp, [::]:32773-&gt;30303/tcp el-1-geth-lighthouse--2f9bb3e401584721b928ecd01eb3a99d コンテナのシェルに接続 1$ sudo docker exec -it &lt;コンテナID&gt; geth attach --datadir /data/geth/execution-data gethが立ち上がると以下のような文章が表示される 12345678Welcome to the Geth JavaScript console!instance: Geth/v1.16.3-stable-d818a9af/linux-amd64/go1.24.6at block: 21 (Thu Sep 25 2025 07:25:34 GMT+0000 (UTC)) datadir: /data/geth/execution-data modules: admin:1.0 debug:1.0 engine:1.0 eth:1.0 miner:1.0 net:1.0 rpc:1.0 txpool:1.0 web3:1.0To exit, press ctrl-d or type exit 以下のコマンドを入力して，clefに保存されたアカウントを呼び出す 1&gt; eth.accounts[0] clefのコンソールに以下のようなメッセージが表示されるのでyと入力 1234567891011121314-------- List Account request--------------A request has been made to list all accounts.You can select which accounts the caller can see [x] 0x930620D7C29043423BaE931A4A88345a2ff725a6 URL: keystore:///root/.clef/keystore/UTC--2025-09-25T06-21-29.776639348Z--930620d7c29043423bae931a4a88345a2ff725a6-------------------------------------------Request context: 172.17.0.1:32892 -&gt; http -&gt; 172.25.82.171:50000Additional HTTP header data, provided by the external caller: User-Agent: &quot;Go-http-client/1.1&quot; Origin: &quot;&quot;Approve? [y/N]:&gt; gethの方に戻り，以下のようにアドレスが表示されたらOK 1&quot;0x930620d7c29043423bae931a4a88345a2ff725a6&quot; 残高を確認するために，gethで以下のコマンドを入力． 1web3.fromWei(eth.getBalance(eth.accounts[0])) clef側で鍵へのアクセスを許可すると以下のように表示されます． 1100 network-params.ymlで100ETHを指定していた場合，100という応答が得られればOK 送金適当なアドレス0xcA5EB5ce7A5e4808e2243c9336d3DC7221Fb9855に対して10ETH送金します．※コマンドの実行毎にclefで許可しないといけないが，ここでは記述省略 まずは，両者の残高確認． 1234&gt; web3.fromWei(eth.getBalance(eth.accounts[0]))100&gt; web3.fromWei(eth.getBalance(&quot;0xcA5EB5ce7A5e4808e2243c9336d3DC7221Fb9855&quot;))0 続いて送金トランザクションを生成し送金．※ここではclefでパスワード入力が求められる 12345678910111213141516171819202122232425&gt; eth.sendTransaction({from: eth.accounts[0], to: &quot;0xcA5EB5ce7A5e4808e2243c9336d3DC7221Fb9855&quot;, value: web3.toWei(10, &quot;ether&quot;)})&quot;0x7f4c40a7905ab618b9985a64f09e7566255281588083bfc1253e1d8c0ef8926a&quot;&gt; eth.getTransaction(&quot;0x7f4c40a7905ab618b9985a64f09e7566255281588083bfc1253e1d8c0ef8926a&quot;){ accessList: [], blockHash: &quot;0x20d55cad337260446b65d449b5deb471656740248a80434cbee697961430a79a&quot;, blockNumber: 89, chainId: &quot;0x8f082&quot;, from: &quot;0x930620d7c29043423bae931a4a88345a2ff725a6&quot;, gas: 21000, gasPrice: 6903, hash: &quot;0x7f4c40a7905ab618b9985a64f09e7566255281588083bfc1253e1d8c0ef8926a&quot;, input: &quot;0x&quot;, maxFeePerGas: 15775, maxPriorityFeePerGas: 1, nonce: 0, r: &quot;0x1d7eb51d3bccae59bb21e9b3a85d686dc085e26671f29dd3878f4b517efce41f&quot;, s: &quot;0x3982f96fed13fab88c9af46e430ccd7fcfb722f2da683803de4dc96fb532a3f2&quot;, to: &quot;0xca5eb5ce7a5e4808e2243c9336d3dc7221fb9855&quot;, transactionIndex: 0, type: &quot;0x2&quot;, v: &quot;0x1&quot;, value: 10000000000000000000, yParity: &quot;0x1&quot;} 最後に両者の残高を確認．送信元のアカウントからは10ETHと手数料が引き落とされ，宛先のアカウントには10ETHが入金されていることがわかります． 12345&gt; web3.fromWei(eth.getBalance(eth.accounts[0]))89.999999999855037&gt; web3.fromWei(eth.getBalance(&quot;0xcA5EB5ce7A5e4808e2243c9336d3DC7221Fb9855&quot;))10&gt; 最初からやり直したい場合12sudo docker ps -aq | xargs sudo docker rm -fsudo docker volume ls -q | xargs sudo docker volume rm 参考文献Private Networks via Kurtosis | go-ethereum https://geth.ethereum.org/docs/fundamentals/kurtosisGitHub - ethpandaops/ethereum-package: A Kurtosis package that deploys a private, portable, and modular Ethereum devnet https://github.com/ethpandaops/ethereum-package","link":"/2025/09/25/PoS%E7%A7%BB%E8%A1%8C%E5%BE%8C%E3%81%AEEthereum%E3%83%97%E3%83%A9%E3%82%A4%E3%83%99%E3%83%BC%E3%83%88%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%97%E9%80%81%E9%87%91%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/"},{"title":"WindowsでYubikeyを使ってSSH鍵を管理する(ssh-agent周りの設定)","text":"概要YubikeyのOpenPGP機能を利用してSSH秘密鍵を管理したい。その際、ssh-agenの設定が難しかったので、一番簡単だと思うやり方を紹介します。 鍵の生成は以下の記事を参考にすれば特に難しくはなかったので、鍵生成が済んでいてYubikeyへの書き込みが終わっている前提で話を進めます。YubikeyでOpenPGP鍵をセキュアに使う | κeenのHappy Hacκing Blog ssh-agentの無効化田+Rキーを押して「ファイル名を指定して実行」ウィンドウを開きます。services.mscと入力し、OKをクリック OpenSSH Authentication Agentというサービスをダブルクリックし、スタートアップの種類を無効にします。※実行中の場合は停止ボダンで殺しておいてください。 wsl-ssh-pagentの導入wsl-ssh-pagentのリリースページから最新のwsl-ssh-pageant-amd64-gui.exeをダウンロードします。 ダウンロードしたら適当なディレクトリに配置してください。今回はC:\\bin\\wsl-ssh-pageant-amd64-gui.exeに配置しました。 wsl-ssh-pagentの自動起動設定を行います。タスクスケジューラを立ち上げ、右側のリストからタスクの作成をクリックします。新しいタスクを次のように作成してください 全般タブ ssh-agentなど任意の名前を入力 「ユーザーがログインしているときのみ実行する」から変更しない トリガータブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 タスクの開始:ログオン時 設定: 任意のユーザー 有効: チェックを入れる 操作タブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 操作: プログラムの開始 プログラム: 先ほど配置したC:\\bin\\wsl-ssh-pageant-amd64-gui.exeを入力(もしくは「参照…」をクリックして検索) 引数の追加: --systray --winssh openssh-ssh-agent※タスクトレイに常駐させたくない場合は--winssh openssh-ssh-agent gpg-agentの設定Kleopatlaを立ち上げ、設定 -&gt; Kleopatlaを設定の順でクリックします 新しいウィンドウが開くので、左側の錠前のアイコンGnuPGシステムをクリック。プライベート鍵タブから、puttyサポートを有効にするのチェックを入れます。 最後にOKをクリックして終了します gpg-agentの自動起動設定を行います。タスクスケジューラを立ち上げ、右側のリストからタスクの作成をクリックします。新しいタスクを次のように作成してください 全般タブ gpg-agentなど任意の名前を入力 「ユーザーがログインしているときのみ実行する」から変更しない トリガータブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 タスクの開始:ログオン時 設定: 任意のユーザー 有効: チェックを入れる 操作タブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 操作: プログラムの開始 プログラム: &quot;C:\\Program Files (x86)\\GnuPG\\bin\\gpg-connect-agent.exe&quot;を入力(もしくは「参照…」をクリックして検索) 引数の追加: updatestartuptty /bye 動作確認ターミナル上でssh-add -Lを入力します。このとき、Yubikeyが刺さっていれば公開鍵が表示されるはずです。ここで表示した公開鍵をサーバに追加して利用してください。 (おまけ) Git for Windowsでの使い方以下の設定を行い、CygWinから内蔵のOpenSSHにsshクライアントを切り替える。 1git config --global core.sshCommand &quot;C:/Windows/System32/OpenSSH/ssh.exe&quot; 参考文献YubikeyでOpenPGP鍵をセキュアに使う | κeenのHappy Hacκing Blog benpye/wsl-ssh-pageant: A Pageant -&gt; TCP bridge for use with WSL, allowing for Pageant to be used as an ssh-ageant within the WSL environment. 混沌を極めるWindowsのssh-agent事情 #Windows - Qiita GitをWindows10のOpenSSHを使うように設定する - lisz-works OpenSSH Authentication Agentというサービスをダブルクリックし、スタートアップの種類を無効にします。 実行中の場合は停止ボダンで殺しておいてください。 wsl-ssh-pagentの導入wsl-ssh-pagentのリリースページから最新のwsl-ssh-pageant-amd64-gui.exeをダウンロードします。 ダウンロードしたら適当なディレクトリに配置してください。今回はC:\\bin\\wsl-ssh-pageant-amd64-gui.exeに配置しました。 wsl-ssh-pagentの自動起動設定を行います。タスクスケジューラを立ち上げ、右側のリストからタスクの作成をクリックします。新しいタスクを次のように作成してください 全般タブ ssh-agentなど任意の名前を入力 「ユーザーがログインしているときのみ実行する」から変更しない トリガータブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 タスクの開始:ログオン時 設定: 任意のユーザー 有効: チェックを入れる 操作タブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 操作: プログラムの開始 プログラム: 先ほど配置したC:\\bin\\wsl-ssh-pageant-amd64-gui.exeを入力(もしくは「参照…」をクリックして検索) 引数の追加: --systray --winssh openssh-ssh-agent※タスクトレイに常駐させたくない場合は--winssh openssh-ssh-agent gpg-agentの設定Kleopatlaを立ち上げ、設定 -&gt; Kleopatlaを設定の順でクリックします 新しいウィンドウが開くので、左側の錠前のアイコンGnuPGシステムをクリック。プライベート鍵タブから、puttyサポートを有効にするのチェックを入れます。 最後にOKをクリックして終了します gpg-agentの自動起動設定を行います。タスクスケジューラを立ち上げ、右側のリストからタスクの作成をクリックします。新しいタスクを次のように作成してください 全般タブ gpg-agentなど任意の名前を入力 「ユーザーがログインしているときのみ実行する」から変更しない トリガータブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 タスクの開始:ログオン時 設定: 任意のユーザー 有効: チェックを入れる 操作タブ左下の「新規」をクリックして設定画面を開き、以下のように設定。 操作: プログラムの開始 プログラム: &quot;C:\\Program Files (x86)\\GnuPG\\bin\\gpg-connect-agent.exe&quot;を入力(もしくは「参照…」をクリックして検索) 引数の追加: updatestartuptty /bye 動作確認ターミナル上でssh-add -Lを入力します。このとき、Yubikeyが刺さっていれば公開鍵が表示されるはずです。ここで表示した公開鍵をサーバに追加して利用してください。 (おまけ) Git for Windowsでの使い方以下の設定を行い、CygWinから内蔵のOpenSSHにsshクライアントを切り替える。 1git config --global core.sshCommand &quot;C:/Windows/System32/OpenSSH/ssh.exe&quot; 参考文献YubikeyでOpenPGP鍵をセキュアに使う | κeenのHappy Hacκing Blog benpye/wsl-ssh-pageant: A Pageant -&gt; TCP bridge for use with WSL, allowing for Pageant to be used as an ssh-ageant within the WSL environment. 混沌を極めるWindowsのssh-agent事情 #Windows - Qiita GitをWindows10のOpenSSHを使うように設定する - lisz-works","link":"/2024/09/26/Windows%E3%81%A7Yubikey%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6SSH%E9%8D%B5%E3%82%92%E7%AE%A1%E7%90%86%E3%81%99%E3%82%8B-ssh-agent%E5%91%A8%E3%82%8A%E3%81%AE%E8%A8%AD%E5%AE%9A/"},{"title":"certbotとngixの競合でnginxが勝手に落ちる不具合の解消","text":"概要・certbotがnginxを殺してた・設定ミスがありcertbotが更新にコケていた・crontabを使用していたが、更新用のdaemonが裏で動いていて、予期せぬ時刻に障害が発生した 事の発端ある日、自宅のサーバで運用しているWebページが落ちていることに気がつき、 その理由を探ったところ、SSLアクセラレータとして使っているnginxのサービスが停止しているようだった。 落ちてから1時間ぐらいすると生き返ると言う状況から当初はリソース不足かと思い、VMのメモリ割り当てを4GBまで増やして再起動したところ正常に復旧した。 しかし、翌日またnginxが落ちておりヤケクソでvCPUを8コア/メモリ割り当てを64GBにしたが、nginxは落ちてしまった。 原因究明/var/log/messages/ を見たら速攻で分かった。 1234567891011121314Apr 24 10:22:23 *hostname* systemd[1]: Starting This service automatically renews any certbot certificates found...Apr 24 10:22:24 *hostname* certbot[99744]: Saving debug log to /var/log/letsencrypt/letsencrypt.logApr 24 10:22:24 *hostname* certbot[99744]: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Apr 24 10:22:24 *hostname* certbot[99744]: Processing /etc/letsencrypt/renewal/*****.confApr 24 10:22:24 *hostname* certbot[99744]: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Apr 24 10:22:25 *hostname* certbot[99744]: Certificate not yet due for renewalApr 24 10:22:25 *hostname* certbot[99744]: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Apr 24 10:22:25 *hostname* certbot[99744]: Processing /etc/letsencrypt/renewal/*****.confApr 24 10:22:25 *hostname* certbot[99744]: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Apr 24 10:22:27 *hostname* systemd[1]: Stopping The nginx HTTP and reverse proxy server...Apr 24 10:22:27 *hostname* systemd[1]: nginx.service: Deactivated successfully.Apr 24 10:22:27 *hostname* systemd[1]: Stopped The nginx HTTP and reverse proxy server.Apr 24 10:22:27 *hostname* systemd[1]: nginx.service: Consumed 26.757s CPU time.Apr 24 10:22:27 *hostname* certbot[99744]: Renewing an existing certificate for ***** certbotが証明書を更新する際にnginxが落とされていた。しかも悪いことに証明書の更新にコケて固まっていた模様。(しばらくするとタイムアウトになってnginxが甦生される) 証明書の更新にコケた理由certbotが延々と遅延していた理由としては、firewalldの設定が間違っていて80番ポートが塞がっていたのでACMEチャレンジで延々と待たされていただけのようであった。 予期せぬタイミングで動作したcertbot自分の場合、certbotは毎月1日の午前3時に動かすようcrontabを組んでいたが何故か4/24にも障害が発生。こちらも気になったので調査してみた。 その結果、certbot-renew.timerというサービスが存在している事が判明。 対策firewalldの設定変更以下のコマンドで80番を穴開け 12sudo firewall-cmd --permanent --zone=dmz --add-service=httpsudo firewall-cmd --reload crontabからcertbot-renew.timerへの切り替え今回は何故かcrontabの方にしか設定していないpre-hookとpost-hookが動いていたようだが、この際なのできちんと設定を行っておく /etc/sysconfig/certbot ファイルをお好みのエディタで開いてPRE_HOOKとPOST_HOOKの行を以下の通り書き換えればOK 12PRE_HOOK=&quot;--pre-hook 'systemctl stop nginx'&quot;POST_HOOK=&quot;--post-hook 'systemctl restart nginx'&quot; 最後にcertbot-renew.timerを再起動しておく 1systemctl restart certbot-renew.timer 参考文献【簡単】Let’s Encryptの自動更新をcronなしで実現しよう | TACK-WEB","link":"/2024/04/25/certbot%E3%81%A8ngix%E3%81%AE%E7%AB%B6%E5%90%88%E3%81%A7nginx%E3%81%8C%E5%8B%9D%E6%89%8B%E3%81%AB%E8%90%BD%E3%81%A1%E3%82%8B%E4%B8%8D%E5%85%B7%E5%90%88%E3%81%AE%E8%A7%A3%E6%B6%88/"},{"title":"トップページ","text":"サイト概要 このブログにはシステム構築等の技術的なメモを備忘録として残します。 自己紹介趣味でサーバを立てたり、自宅ネットワークを弄ったりしています 現在の遊び環境は以下の通り。仮想マシン上で色々動かしてます。 12345機種: DELL PowerEdge R430CPU: Intel Xeon E3-2620v4*1RAM: 128GBHDD: 2TB*4SSD: 240GB*1","link":"/2038/01/19/index/"},{"title":"ungoogled-chromiumでdアニメストア&#x2F;Amazon PrimeVideo&#x2F;Neflix&#x2F;U-NEXT等を見られるようにする方法","text":"概要ungoogled-chromium等のChromium系ブラウザを使用していると，dアニメストア/Amazon PrimeVideo/Netflix/U-NEXTなどの動画配信サービスで次のようなエラーが発生し，動画が見られない現象が発生する事があります． この記事では，dアニメストアを例にしてungoogled-chromiumで動画が再生できるようにしていきます．また，本記事の対象プラットフォームはWindowsのみになります． 解決できるかどうかの確認まずは，本記事のやり方で問題が解決できるかを確認します． chrome://componentsを開き，Widevine Content Decryption Moduleの状態が最新やNewではないことを確認してください．(以下の画像では「確認中」となっています)．※特にバージョンが0.0.0.0の場合は解決できる可能性が高いです 上記に当てはまる場合，動画が再生できない原因はDRMの可能性が高いです．本来あらゆる知識は公共に属し無制限に活用され得るべきですが，DRMはオープンな暗号技術を用いてこれを阻害します．ChromiumではWidevineというプラグインがDRMに利用されているため，手動でこのプラグインを導入していきます． Chromiumのインストール先を開く一般的にChromiumのインストール先は以下の場所になります．C:\\Users\\%UserName%\\AppData\\Local\\Chromium\\Application\\特にオプションを弄っていない場合は，ここのフォルダを開いてください． 自分で別の場所を指定している場合は指定した場所を開いてください． すると，次のようにバージョン番号ごとにフォルダが存在するので，一番最新のバージョン番号のフォルダを開きます． このようなフォルダが見えていれば正しいパスになります．このフォルダを開いたままにしておいてください． Edgeのインストール先を開くChromiumの時とほぼ同じになります． Edgeのインストール先を開きますC:\\Program Files (x86)\\Microsoft\\Edge\\Application すると，次のようにバージョン番号ごとにフォルダが存在するので，一番最新のバージョン番号のフォルダを開きます． このようなフォルダが見えていれば正しいパスになります．このフォルダを開いたままにしておいてください． EdgeのフォルダからChromiumのフォルダにコピーするEdge側のフォルダに入っているWidevineCdmフォルダをChromium側にコピーします．(Ctrlを押しながらドラッグ&amp;ドロップ) Chromiumを起動したままの状態であれば一度閉じてください． 確認chrome://componentsを開き，Widevine Content Decryption Moduleのバージョンが変化していることを確認してください． エラーが解消し，動画が再生されれば成功です．※スクリーンショットでは動画部分が真っ黒に見えますが実際には再生されています．","link":"/2025/04/26/ungoogled-chromium%E3%81%A7d%E3%82%A2%E3%83%8B%E3%83%A1%E3%82%B9%E3%83%88%E3%82%A2-Amazon-PrimeVideo-Neflix-U-NEXT%E7%AD%89%E3%82%92%E8%A6%8B%E3%82%89%E3%82%8C%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/"},{"title":"wireguardでIPv6を利用する設定(疑似 IPv6 over IPv4)","text":"概要WireguardでIPv6通信ができるようにします。 環境OS: Ubuntu 22.04.4 LTSプラットフォーム: OCI無料枠 事前準備ip6tablesを使えるようにするubuntuであればあらかじめインストールされていると思います。 カーネルの設定でIPv6フォワードを有効にする/etc/sysctl.confを任意のテキストエディタで開き、ファイルの末尾に以下の設定を追加します 12net.ipv4.ip_forward=1net.ipv6.conf.all.forwarding=1 その後端末を再起動します 設定まずはIPv6のULAアドレス(ローカルIP)を生成します。Unique Local IPv6 Generator※fd00::/8を使ってもよいですが、推奨されていないようです。 次にwireguardのコンフィグを投入します。 IPv4のローカルIPを172.24.255.0/24先ほど生成したIPv6のULAをfdac:756c:6733::/48とすると以下の通りです サーバー123456789101112[Interface]PrivateKey = ****Address = 172.24.255.1/24, fdac:756c:6733::1/48ListenPort = 51820SaveConfig = falseMTU = 1374 # これぐらいにすると通信が安定するPostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o ens3 -j MASQUERADEPostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE;ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o ens3 -j MASQUERADE[Peer]PublicKey = ***AllowedIPs = 172.24.255.2/32, fdac:756c:6733::2/128 クライアント12345678910[Interface]PrivateKey = ***Address = 172.24.255.2/32, fdac:756c:6733::2/128DNS = 2606:4700:4700::1111, 2606:4700:4700::1001, 1.1.1.1, 1.0.0.1MTU = 1374[Peer]PublicKey = ***AllowedIPs = 0.0.0.0/0, ::/0Endpoint = 203.0.113.55:51820 参考文献Linux で IP 転送を有効にする方法Chat GPT","link":"/2024/06/29/wireguard%E3%81%A7IPv6%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E8%A8%AD%E5%AE%9A-%E7%96%91%E4%BC%BC-IPv6-over-IPv4/"}],"tags":[{"name":"サーバ","slug":"サーバ","link":"/tags/%E3%82%B5%E3%83%BC%E3%83%90/"},{"name":"広告ブロック","slug":"広告ブロック","link":"/tags/%E5%BA%83%E5%91%8A%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ネットワーク","slug":"ネットワーク","link":"/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"},{"name":"セキュリティ","slug":"セキュリティ","link":"/tags/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/"},{"name":"Ethereum","slug":"Ethereum","link":"/tags/Ethereum/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"}],"categories":[{"name":"サーバ","slug":"サーバ","link":"/categories/%E3%82%B5%E3%83%BC%E3%83%90/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"環境構築","slug":"サーバ/環境構築","link":"/categories/%E3%82%B5%E3%83%BC%E3%83%90/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"セキュリティ","slug":"サーバ/セキュリティ","link":"/categories/%E3%82%B5%E3%83%BC%E3%83%90/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/"},{"name":"ネットワーク","slug":"サーバ/ネットワーク","link":"/categories/%E3%82%B5%E3%83%BC%E3%83%90/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"},{"name":"設定","slug":"Windows/設定","link":"/categories/Windows/%E8%A8%AD%E5%AE%9A/"},{"name":"障害復旧","slug":"サーバ/障害復旧","link":"/categories/%E3%82%B5%E3%83%BC%E3%83%90/%E9%9A%9C%E5%AE%B3%E5%BE%A9%E6%97%A7/"},{"name":"Office","slug":"Windows/Office","link":"/categories/Windows/Office/"},{"name":"環境構築","slug":"Linux/環境構築","link":"/categories/Linux/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/"}],"pages":[{"title":"","text":"ツールOCI Bucket ViewerOCIの事前承認済リクエストを利用して，バケットのファイル一覧を表示・ダウンロード可能なGUIです． ワンドライブ直リン生成器OneDriveの共有リンクから直リンクURLを生成します QR生成器QRコードをローカルで生成します．","link":"/tools.html"}]}